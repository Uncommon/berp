@using Berp;
@helper CallProduction(ProductionRule production)
{
	switch(production.Type)
	{
		case ProductionRuleType.Start:
				@:StartRule(context, RuleType.@production.RuleName);
			break;
		case ProductionRuleType.End:
				@:EndRule(context, RuleType.@production.RuleName);
			break;
		case ProductionRuleType.Process:
				@:Build(context, token);
			break;
	}
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{
	@:var error = new ParserError(token, new string[] {"@Raw(string.Join("\", \"", expectedTokens))"}, "State: @state.Id - @Raw(state.Comment)");
	@:if (StopAtFirstError)
		@:throw new ParserException(ParserMessageProvider, error);

	@:context.Errors.Add(error);
	@:return @state.Id;
}
@helper MatchToken(TokenType tokenType)
{
	@:context.TokenMatcher.Match_@(tokenType)(token)
}
using System;
using System.Collections.Generic;
namespace @Model.Namespace
{
	public enum TokenType
	{
		None,
		@foreach(var rule in Model.RuleSet.TokenRules)
		{
			@rule.Name.Replace("#", "")@:,
		}
	}

	public enum RuleType
	{
		None,
		@foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
		{
			@rule.Name.Replace("#", "_")@:, // @rule.ToString(true)
		}
	}

    public partial class ParserError
    {
        public string StateComment { get; private set; }

        public Token ReceivedToken { get; private set; }
        public string[] ExpectedTokenTypes { get; private set; }

        public ParserError(Token receivedToken, string[] expectedTokenTypes, string stateComment)
        {
            this.ReceivedToken = receivedToken;
            this.ExpectedTokenTypes = expectedTokenTypes;
            this.StateComment = stateComment;
        }
    }

    public partial class ParserException : Exception
    {
        private ParserError[] errors = new ParserError[0];

        public ParserError[] Errors { get { return errors; } }

        public ParserException() { }
        public ParserException(string message) : base(message) { }
        public ParserException(string message, Exception inner) : base(message, inner) { }

        public ParserException(ParserMessageProvider messageProvider, params ParserError[] errors) 
			: base(messageProvider.GetDefaultExceptionMessage(errors))
        {
            if (errors != null)
                this.errors = errors;
        }
    }

    public class @Model.ParserClassName
    {
		public bool StopAtFirstError { get; set;}
		public ParserMessageProvider ParserMessageProvider { get; private set; }

		class ParserContext
		{
			public TokenScanner TokenScanner { get; set; }
			public TokenMatcher TokenMatcher { get; set; }
			public AstBuilder Builder { get; set; }
			public Queue<Token> TokenQueue { get; set; }
			public List<ParserError> Errors { get; set; }
		}

		public @(Model.ParserClassName)() : this(new ParserMessageProvider())
		{
		}

		public object Parse(TokenScanner tokenScanner)
		{
			return Parse(tokenScanner, new TokenMatcher(), new AstBuilder());
		}

		public @(Model.ParserClassName)(ParserMessageProvider parserMessageProvider)
		{
			this.ParserMessageProvider = parserMessageProvider;
		}

        public object Parse(TokenScanner tokenScanner, TokenMatcher tokenMatcher, AstBuilder astBuilder)
		{
			var context = new ParserContext
			{
				TokenScanner = tokenScanner,
				TokenMatcher = tokenMatcher,
				Builder = astBuilder,
				TokenQueue = new Queue<Token>(),
				Errors = new List<ParserError>()
			};

			StartRule(context, RuleType.@Model.RuleSet.StartRule.Name);
            int state = 0;
            Token token;
            do
			{
				token = ReadToken(context);
				state = MatchToken(state, token, context);
            } while(!token.IsEOF);

			if (context.Errors.Count > 0)
			{
				throw new ParserException(ParserMessageProvider, context.Errors.ToArray());
			}

			if (state != @Model.EndState.Id)
			{
				throw new InvalidOperationException("One of the grammar rules expected #EOF explicitly.");
			}

			EndRule(context, RuleType.@Model.RuleSet.StartRule.Name);
			return GetResult(context);
		}

		void Build(ParserContext context, Token token)
		{
			context.Builder.Build(token);
		}

		void StartRule(ParserContext context, RuleType ruleType)
		{
			context.Builder.StartRule(ruleType);
		}

		void EndRule(ParserContext context, RuleType ruleType)
		{
			context.Builder.EndRule(ruleType);
		}

		object GetResult(ParserContext context)
		{
			return context.Builder.GetResult();
		}

		Token ReadToken(ParserContext context)
		{
			return context.TokenQueue.Count > 0 ? context.TokenQueue.Dequeue() : context.TokenScanner.Read();
		}

		int MatchToken(int state, Token token, ParserContext context)
		{
			int newState;
			switch(state)
			{
			@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
			{
				@:case @state.Id:
					@:newState = MatchTokenAt_@(state.Id)(token, context);
					@:break;
			}
				default:
					throw new InvalidOperationException("Unknown state: " + state);
			}
			return newState;
		}

	@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
	{
		<text>
		// @Raw(state.Comment)
		int MatchTokenAt_@(state.Id)(Token token, ParserContext context)
		{
			@foreach(var transition in state.Transitions)
			{
			@:if (@MatchToken(transition.TokenType))
			@:{
				if (transition.LookAheadHint != null)
				{
				@:if (LookAhead_@(transition.LookAheadHint.Id)(context, token))
				@:{
				}
				foreach(var production in transition.Productions)
				{
					@CallProduction(production)
				}
				@:return @transition.TargetState;
				if (transition.LookAheadHint != null)
				{
				@:}
				}
			@:}
			}
			@HandleParserError(state.Transitions.Select(t => "#" + t.TokenType.ToString()).Distinct(), state)
		}
		</text>
	}

	@foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
	{
		<text>
		bool LookAhead_@(lookAheadHint.Id)(ParserContext context, Token currentToken)
		{
			currentToken.Detach();
            Token token;
			var queue = new Queue<Token>();
			bool match = false;
		    do
		    {
		        token = ReadToken(context);
				token.Detach();
		        queue.Enqueue(token);

		        if (false
				@foreach(var tokenType in lookAheadHint.ExpectedTokens)
				{
					@:|| @MatchToken(tokenType)
				}
				)
		        {
					match = true;
					break;
		        }
		    } while (false
			@foreach(var tokenType in lookAheadHint.Skip)
			{
				@:|| @MatchToken(tokenType)
			}
			);
			foreach(var t in queue)
				context.TokenQueue.Enqueue(t);
			return match;
		}
		</text>
	}
	}
}